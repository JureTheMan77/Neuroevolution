%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% datoteka diploma-FRI-vzorec.tex
%
%POZOR: ta verzija ne producira pdf datoteke v pdf/A formatu!!!
%namenjena je le za nalogo pri Diplomskem seminarju!
%
% vzorčna datoteka za pisanje diplomskega dela v formatu LaTeX
% na UL Fakulteti za računalništvo in informatiko
%
% na osnovi starejših verzij vkup spravil Franc Solina, maj 2021
% prvo verzijo je leta 2010 pripravil Gašper Fijavž
%
% za upravljanje z literaturo ta vezija uporablja BibLaTeX
%
% svetujemo uporabo Overleaf.com - na tej spletni implementaciji LaTeXa ta vzorec zagotovo pravilno deluje
%

\documentclass[a4paper,12pt,openright]{book}
%\documentclass[a4paper, 12pt, openright, draft]{book}  Nalogo preverite tudi z opcijo draft, ki pokaže, katere vrstice so predolge! Pozor, v draft opciji, se slike ne pokažejo!

\usepackage[utf8]{inputenc}   % omogoča uporabo slovenskih črk kodiranih v formatu UTF-8
\usepackage[slovene,english]{babel}    % naloži, med drugim, slovenske delilne vzorce
\usepackage[pdftex]{graphicx}  % omogoča vlaganje slik različnih formatov
\usepackage{fancyhdr}          % poskrbi, na primer, za glave strani
\usepackage{amssymb}           % dodatni matematični simboli
\usepackage{amsmath}           % eqref, npr.
\usepackage{hyperxmp}
\usepackage[hyphens]{url}
\usepackage{csquotes}
\usepackage[pdftex, colorlinks=true,
    citecolor=black, filecolor=black,
    linkcolor=black, urlcolor=black,
    pdfproducer={LaTeX}, pdfcreator={LaTeX}]{hyperref}

\usepackage{color}
\usepackage{soul}

\usepackage[
    backend=biber,
    style=numeric,
    sorting=nty,
]{biblatex}


\addbibresource{literatura.bib} %Imports bibliography file

\usepackage{svg}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	DIPLOMA INFO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ttitle}{Nevroevolucija za strojno učenje}
\newcommand{\ttitleEn}{Neuroevolution for machine learning}
\newcommand{\tsubject}{\ttitle}
\newcommand{\tsubjectEn}{\ttitleEn}
\newcommand{\tauthor}{Jure Vreček}
\newcommand{\tkeywords}{nevroevolucija, strojno učenje, nevronske mreže, rekurenčne nevronske mreže, genetski algoritem}
\newcommand{\tkeywordsEn}{neuroevolution, machine learning, neural networks, recurrent neural networks, genetic algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	HYPERREF SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{pdftitle={\ttitle}}
\hypersetup{pdfsubject=\ttitleEn}
\hypersetup{pdfauthor={\tauthor}}
\hypersetup{pdfkeywords=\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% postavitev strani
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addtolength{\marginparwidth}{-20pt} % robovi za tisk
\addtolength{\oddsidemargin}{40pt}
\addtolength{\evensidemargin}{-40pt}

\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami
\setlength{\headheight}{15pt}        % potreben prostor na vrhu
\renewcommand{\chaptermark}[1]%
{\markboth{\MakeUppercase{\thechapter.\ #1}}{}} \renewcommand{\sectionmark}[1]%
{\markright{\MakeUppercase{\thesection.\ #1}}} \renewcommand{\headrulewidth}{0.5pt} \renewcommand{\footrulewidth}{0pt}
\fancyhf{}
\fancyhead[LE,RO]{\sl \thepage}
%\fancyhead[LO]{\sl \rightmark} \fancyhead[RE]{\sl \leftmark}
\fancyhead[RE]{\sc \tauthor}              % dodal Solina
\fancyhead[LO]{\sc Diplomska naloga}     % dodal Solina


\newcommand{\BibLaTeX}{{\sc Bib}\LaTeX}
\newcommand{\BibTeX}{{\sc Bib}\TeX}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% naslovi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\autfont}{\Large}
\newcommand{\titfont}{\LARGE\bf}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\setcounter{tocdepth}{1}          % globina kazala

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% konstrukti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{izrek}{Izrek}[chapter]
\newtheorem{trditev}{Trditev}[izrek]
\newenvironment{dokaz}{\emph{Dokaz.}\ }{\hspace{\fill}{$\Box$}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PDF-A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% define medatata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\Title{\ttitle}
\def\Author{\tauthor, jv9074@fri.uni-lj.si}
\def\Subject{\ttitleEn}
\def\Keywords{\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \convertDate converts D:20080419103507+02'00' to 2008-04-19T10:35:07+02:00
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\convertDate{%
    \getYear
}

{\catcode`\D=12
\gdef\getYear D:#1#2#3#4{\edef\xYear{#1#2#3#4}\getMonth}
}
\def\getMonth#1#2{\edef\xMonth{#1#2}\getDay}
\def\getDay#1#2{\edef\xDay{#1#2}\getHour}
\def\getHour#1#2{\edef\xHour{#1#2}\getMin}
\def\getMin#1#2{\edef\xMin{#1#2}\getSec}
\def\getSec#1#2{\edef\xSec{#1#2}\getTZh}
\def\getTZh +#1#2{\edef\xTZh{#1#2}\getTZm}
\def\getTZm '#1#2'{%
    \edef\xTZm{#1#2}%
    \edef\convDate{\xYear-\xMonth-\xDay T\xHour:\xMin:\xSec+\xTZh:\xTZm}%
}

%\expandafter\convertDate\pdfcreationdate

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get pdftex version string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcount\countA
\countA=\pdftexversion
\advance \countA by -100
\def\pdftexVersionStr{pdfTeX-1.\the\countA.\pdftexrevision}
\interfootnotelinepenalty=10000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XMP data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xmpincl}
%\includexmp{pdfa-1b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pdfInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pdfinfo{%
    /Title    (\ttitle)
    /Author   (\tauthor, damjan@cvetan.si)
    /Subject  (\ttitleEn)
    /Keywords (\tkeywordsEn)
    /ModDate  (\pdfcreationdate)
    /Trapped /False
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% znaki za copyright stran
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\CcImageCc}[1]{%
    \includegraphics[scale=#1]{cc_cc_30.pdf}%
}
\newcommand{\CcImageBy}[1]{%
    \includegraphics[scale=#1]{cc_by_30.pdf}%
}
\newcommand{\CcImageSa}[1]{%
    \includegraphics[scale=#1]{cc_sa_30.pdf}%
}

%%%
% custom ukazi
%%%

\newcommand{\lstlistingslo}{\lstinputlisting[language=C++, breaklines=true, extendedchars=true, breakatwhitespace=true, literate={č}{{\v{c}}}1 {š}{{\v{s}}}1 {ž}{{\v{z}}}1]}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
    \selectlanguage{slovene}
    \frontmatter
    \setcounter{page}{1} %
    \renewcommand{\thepage}{}       % preprečimo težave s številkami strani v kazalu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%naslovnica

    \thispagestyle{empty}%
    \begin{center}
    {\large\sc Univerza v Ljubljani\\%
    Fakulteta za računalništvo in informatiko\\%
    }
        \vskip 10em%
            {\autfont \tauthor\par}%
            {\titfont \ttitle \par}%
            {\vskip 3em \textsc{DIPLOMSKO DELO\\[5mm]         % dodal Solina za ostale študijske programe
%    VISOKOŠOLSKI STROKOVNI ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
        UNIVERZITETNI ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ MULTIMEDIJA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ UPRAVNA INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ RAČUNALNIŠTVO IN MATEMATIKA}\par}%
        \vfill\null%
% izberite pravi habilitacijski naziv mentorja!
        {\large \textsc{Mentor}: prof. dr. Marko Robnik Šikonja\par}%
%   {\large \textsc{Somentor}:  viš. pred./doc./izr. prof./prof. dr.  Martin Krpan \par}%
        {\vskip 2em \large Ljubljana, \the\year \par}%
    \end{center}
% prazna stran
%\clearemptydoublepage
% izjava o licencah itd. se izpiše na hrbtni strani naslovnice

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%copyright stran
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \thispagestyle{empty}

    \vspace*{5cm}
    {\small \noindent
    To delo je ponujeno pod licenco \textit{Creative Commons Priznanje avtorstva-Deljenje pod enakimi pogoji 2.5 Slovenija} (ali novej\v so razli\v cico).
    To pomeni, da se tako besedilo, slike, grafi in druge sestavine dela kot tudi rezultati diplomskega dela lahko prosto distribuirajo,
        reproducirajo, uporabljajo, priobčujejo javnosti in predelujejo, pod pogojem, da se jasno in vidno navede avtorja in naslov tega
    dela in da se v primeru spremembe, preoblikovanja ali uporabe tega dela v svojem delu, lahko distribuira predelava le pod
    licenco, ki je enaka tej.
    Podrobnosti licence so dostopne na spletni strani \href{http://creativecommons.si}{creativecommons.si} ali na Inštitutu za
    intelektualno lastnino, Streliška 1, 1000 Ljubljana.

    \vspace*{1cm}
        \begin{center}% 0.66 / 0.89 = 0.741573033707865
            \CcImageCc{0.741573033707865}\hspace*{1ex}\CcImageBy{1}\hspace*{1ex}\CcImageSa{1}%
        \end{center}
    }

    \vspace*{1cm}
    {\small \noindent
    Izvorna koda diplomskega dela, njeni rezultati in v ta namen razvita programska oprema je ponujena pod licenco GNU General Public License,
        različica 3 (ali novejša). To pomeni, da se lahko prosto distribuira in/ali predeluje pod njenimi pogoji.
    Podrobnosti licence so dostopne na spletni strani \url{http://www.gnu.org/licenses/}.
    }

    \vfill
    \begin{center}
        \ \\ \vfill
        {\em
        Besedilo je oblikovano z urejevalnikom besedil \LaTeX.}
    \end{center}

% prazna stran
    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% stran 3 med uvodnimi listi
    \thispagestyle{empty}
    \
    \vfill

    \bigskip
    \noindent\textbf{Kandidat:} Jure Vreček\\
    \noindent\textbf{Naslov:} Neuroevolucija za strojno učenje\\
% vstavite ustrezen naziv študijskega programa!
    \noindent\textbf{Vrsta naloge:} Diplomska naloga na univerzitetnem programu prve stopnje Računalništvo in informatika \\
% izberite pravi habilitacijski naziv mentorja!
    \noindent\textbf{Mentor:} prof. dr. Marko Robnik Šikonja\\
    %\noindent\textbf{Somentor:} isto kot za mentorja

    \bigskip
    \noindent\textbf{Opis:}\\
    Besedilo teme diplomskega dela študent prepiše iz študijskega informacijskega sistema, kamor ga je vnesel mentor.
    V nekaj stavkih bo opisal, kaj pričakuje od kandidatovega diplomskega dela.
    Kaj so cilji, kakšne metode naj uporabi, morda bo zapisal tudi ključno literaturo.

    \bigskip
    \noindent\textbf{Title:} Neuroevolution for machine learning

    \bigskip
    \noindent\textbf{Description:}\\
    opis diplome v angleščini

    \vfill



    \vspace{2cm}

% prazna stran
    \clearemptydoublepage

% zahvala
    \thispagestyle{empty}\mbox{}\vfill\null\it%
    \noindent
    Zahvaljujem se svojemu mentorju za njegovo potrpežljivost.
    \rm\normalfont

% prazna stran
    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% posvetilo, če sama zahvala ne zadošča :-)
    %\thispagestyle{empty}\mbox{}{\vskip0.20\textheight}\mbox{}\hfill\begin{minipage}{0.55\textwidth}%
    %                                                                    Svoji dragi Alenčici.
    %                                                                    \normalfont
    %\end{minipage}

% prazna stran
    \clearemptydoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kazalo
    \pagestyle{empty}
    \def\thepage{}% preprečimo težave s številkami strani v kazalu
    \tableofcontents{}


% prazna stran
    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% seznam kratic

    \chapter*{Seznam uporabljenih kratic}

    \noindent\begin{tabular}{p{0.11\textwidth}|p{.39\textwidth}|p{.39\textwidth}}    % po potrebi razširi prvo kolono tabele na račun drugih dveh!
    \textbf{kratica}
                 & \textbf{angleško}             & \textbf{slovensko}                        \\ \hline
                 \textbf{CA}    &   classification accuracy &   klasifikacijska točnost \\
                 \textbf{NN}    &   neural network    & nevronska mreža \\
                 \textbf{ReLU}    &   rectified linear unit    & usmerjena linearna enota \\
                 \textbf{GA}    &   genetic algorithm    & genetski algoritem \\
                 \textbf{SUS}    &   stochastic universal sampling    & stohastično univerzalno vzorčenje \\
%  \dots & \dots & \dots \\
    \end{tabular}



    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% povzetek
    \addcontentsline{toc}{chapter}{Povzetek}
    \chapter*{Povzetek}

    \noindent\textbf{Naslov:} \ttitle
    \bigskip

    \noindent\textbf{Avtor:} \tauthor
    \bigskip

%\noindent\textbf{Povzetek:}
    %\noindent V vzorcu je predstavljen postopek priprave diplomskega dela z uporabo okolja \LaTeX. Vaš povzetek mora sicer vsebovati približno 100 besed, ta tukaj je odločno prekratek.
    %Dober povzetek vključuje: (1) kratek opis obravnavanega problema, (2) kratek opis vašega pristopa za reševanje tega problema in (3) (najbolj uspešen) rezultat ali prispevek diplomske naloge.
    \noindent To diplomsko delo pokriva opis izdelave rekurenčnih nevronskih mrež z namenskim programom, ki
    pokriva inicializacijo začetne populacije, vzorčenje, križanje, mutiranje in izračun kvalitete.
    Nevronske mreže, ki jih program izdela, so namenjene večrazredni klasifikaciji nad podatkovnimi množicami z zveznimi ali distkretnimi atributi.
    Algoritmi inicializacije, križanja in mutiranja so specifični za namen tega dela.
    Vzorčenje je implementirano s prilagojenim stohastičnim univerzalnem vzorčenjem, kjer se vedno obdrži najboljši agent prejšnje
    generacije, kvaliteta pa se izračuna na podlagi točnosti napovedi ali pa z večrazrednim Matthewsovim korelacijskim koeficientom s pomočjo matrike zmot.
    Pri obeh metodah se lahko upošteva tudi število vozlišč in povezav posamezne nevronske mreže.
    Program je bil razvit s pomočjo množic Iris, Wine, Car Evaluation in Statlog (Shuttle), ki so
    na voljo na UCI Machine Learning Repository~\cite{Dua:2019}.
    V tem poročilu je vključena tudi primerjava z nekaterimi odprtokodnimi rešitvami strojnega učenja, ki so trenutno na voljo.

    \bigskip

    \noindent\textbf{Ključne besede:} \tkeywords.
% prazna stran
    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% abstract
    \selectlanguage{english}
    \addcontentsline{toc}{chapter}{Abstract}
    \chapter*{Abstract}

    \noindent\textbf{Title:} \ttitleEn
    \bigskip

    \noindent\textbf{Author:} \tauthor
    \bigskip

%\noindent\textbf{Abstract:}
    \noindent This diploma thesis describes the creation of recurrent neural networks with a custom program that covers the
    initialization of the initial population, sampling, crossover, mutation and fitness calculation.
    Neural networks, created by the program, are designed for multiclass classification of data in data sets with continuous or discrete attributes.
    Initialization, crossover and mutation algorithms are specific for this thesis.
    Crossover is implemented with a modified stochastic universal sampling algorithm, where the previous generation's fittest agent is always kept.
    Fitness is calculated based on prediction accuracy or on the Matthews correlation coefficient with the help of a confusion matrix.
    Both methods can also take into account the number of vertices and edges of each neural network.
    The program was developed with the help of the following datasets, which are available in the UCI Machine Learning Repository~\cite{Dua:2019}:
    Iris, Wine, Car Evaluation and Statlog (Shuttle).
    This report also includes comparisons with a few open source machine learning solutions available at the time of writing.
    \bigskip

    \noindent\textbf{Keywords:} \tkeywordsEn.
    \selectlanguage{slovene}
% prazna stran
    \clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \mainmatter
    \setcounter{page}{1}
    \pagestyle{fancy}

    \chapter{Uvod}\label{ch:uvod}
    Na področju strojnega učenja je priljubljena
    uporaba nevronskih mrež za napovedovanje na podlagi učenja iz podatkov.
    Topologija teh nevronskih mrež se giblje od enostavnih brez skritih nivojev, do kompleksnih večnivojskih
    s povratnimi povezavami.
    Učenje večinoma poteka z metodo vzvratnega razširjanja napake, kjer se prilagajajo le uteži povezav med vozlišči,
    topologija pa ostane enaka.
    Motivacija diplomskega dela je raziskati, ali učenje z metodo nevroevolucije, kjer poleg uteži spreminjamo tudi topologijo,
    prinese izboljšave pri točnosti, hitrosti učenja in velikosti končnih nevronskih
    mrež v primerjavi s standardnimi rešitvami.

    Naš pristop ustvarja nevronske mreže na podlagi vhodne
    podatkovne množice, izračuna njihovo kvaliteto, nato pa izbere najboljših $n$ za naslednjo generacijo.
    Postopek $m$-krat ponovi, nato pa shrani najboljšo nevronsko mrežo.
    Podrobnosti pristopa so opisane v poglavju~\ref{ch:implementacija-nevroevolucije}.

    Rezultate smo ovrednotili in primerjali z nekaterimi odprtokodnimi rešitvami, ki so trenutno na voljo (poglavje~\ref{ch:evalvacija}).
    % TODO kaj je v zaključku


    \chapter{Ozadje problema}\label{ch:ozadje-problema}
    Poglavje zajema razlago tehnologij, ki jih uporabljamo v tem diplomskem delu: nevronske mreže (razdelek~\ref{sec:nevronske-mreze}),
    genetske algoritme (razdelek~\ref{sec:genetski-algoritmi}) in nevroevolucijo (razdelek~\ref{sec:nevroevolucija}).

    \section{Nevronske mreže}\label{sec:nevronske-mreze}
    Nevronske mreže (NN) so množice povezanih vozlišč oziroma \enquote{nevronov}.
    Njihove lastnosti določata topologija in lastnosti vozlišč~\cite{russell_norvig_2016}.
    Povezave vsebujejo zvezno vrednost uteži, vozlišča pa aktivacijsko funkcijo, ki transformira vsoto uteženih
    aktivacijskih vrednosti vhodnih vozlišč.
    Preprost model vozlišča, predstavljen z diagramom~\ref{fig:diagram-nevrona}, je naslednji~\cite{russell_norvig_2016}:
    \begin{equation}
        a_j=f(\sum_{i=0}^{n} a_i w_{i,j}),
        \label{eq:neuron_model_splosno}
    \end{equation}
    kjer je:
    \begin{itemize}
        \item $a_j$ aktivacijska vrednost trenutnega izhodnega vozlišča,
        \item $f(x)$ aktivacijska funkcija,
        \item $n$ število vhodnih povezav trenutnega vozlišča,
        \item $a_i$ aktivacijska vrednost $i$-tega vhodnega vozlišča in
        \item $w_{i,j}$ utež povezave med $i$-tim in trenutnim vozliščem.
    \end{itemize}

    \begin{figure}[H]
        \begin{center}
            \includesvg[width=12cm]{diagram-nevron.svg}
        \end{center}
        \caption{Diagram nevrona z $n$ vhodnimi povezavami in sigmoidno aktivacijsko funkcijo $f( x) =\frac{1}{1+e^{-x}}$.}
        \label{fig:diagram-nevrona}
    \end{figure}

    V splošnem nevronske mreže (slika~\ref{fig:diagram-mreze}) vsebujejo fiksno število vhodnih in izhodnih vozlišč ter poljubno število vmesnih vozlišč.
    Odvisno od tipa nevronske mreže, so lahko globoka vozlišča združena v skupine, t.i.\ sloje.

    \begin{figure}[H]
        \begin{center}
            \includesvg[width=12cm]{diagram-mreza.svg}
        \end{center}
        \caption{Diagram nevronske mreže s štirimi vhodnimi vozlišči $i$, $n$ globokimi vozlišči $d$ in tremi izhodnimi vozlišči $o$.}
        \label{fig:diagram-mreze}
    \end{figure}


    \subsection{Rekurenčne nevronske mreže}\label{subsec:rekurencne-nevronske-mreze}
    Če povezave med vozlišči lahko tvorijo cikel, nevronske mreže imenujemo rekurenčne~\cite{recurrent_neural_network_wiki} (slika~\ref{fig:diagram-rekurencne-mreze}).
    Z razliko od acikličnih mrež, rekurenčne mreže vsebujejo povezave, ki aktivacijsko vrednost nekaterih vozlišč
    sklenejo z njihovimi predhodniki.

    Koncept združevanja globokih vozlišč v sloje je v teh mrežah zamegljen.
    Namreč, sloji se pojavijo pri vsakem časovnem koraku propagacije vhodnih vrednosti skozi topologijo, zaradi ciklov pa je povsem možno,
    da se neko vozlišče pojavi v več slojih.
    \begin{figure}[H]
        \begin{center}
            \includesvg[width=12cm]{diagram-rekurencne-mreze.svg}
        \end{center}
        \caption{Primer rekurencne nevronske mreže s štirimi vhodnimi vozlišči $i$, tremi globokimi vozlišči $d$ in tremi izhodnimi vozlišči $o$.
        Vozlišča $d_0$, $d_1$, $d_2$ tvorijo medsebojni cikel.}
        \label{fig:diagram-rekurencne-mreze}
    \end{figure}

    \section{Genetski algoritmi}\label{sec:genetski-algoritmi}
    Genetski algoritmi (GA) črpajo navdih iz evolucijskega procesa naravne selekcije.
    Večinoma so uporabljeni za reševanje optimizacijskih in iskalnih problemov, ne zagotavljajo pa optimalnih rešitev.
    Namesto enega rezultata po navadi najdejo nabor rešitev dobre kakovosti, ki so primerne za nadaljnjo uporabo
    ~\cite{inteligentni_sistemi_2010,genetic_algorithm_wiki_2022}.
    
    V splošnem so GA sestavljeni iz korakov inicializiranja začetne populacije, vzorčenja, križanja, mutiranja in izračuna kvalitete agentov.
    %inicializacijo začetne populacije, vzorčenje, križanje, mutiranje in izračun kvalitete
    \begin{description}
        \item[Agent]{je predstavitev posamezne (vmesne ali končne) rešitve. Lahko je zgrajen v obliki vektorja binarnih ali realnih
            števil, znakov, ali pa v obliki drevesa oz. grafa. Posamezno vrednost imenujemo gen in lahko predstavlja navodilo za
            reševanje problema (npr. premik gor, dol, levo ali desno pri sprehodu skozi labirint) ali vrednost nekega parametra problema.}
        \item[Izračun kakovosti]{agentov je specifičen glede na problem, ki ga želimo rešiti. Predstavitev agenta lahko uporabimo
            kot vhodne parametre našega problema in kvaliteto rezultata ustrezno ocenimo. Pri nevroevoluciji
            je kakovost agenta kar točnost klasificiranja.}
        \item[Inicializacija populacije]{je prvi korak GA.
            Ustvarimo začetni nabor naključnih agentov v obliki izbrane predstavitve.
            Velikost populacije je poljubna vrednost, tipično proporcionalna kompleksnosti agentov in zahtevnosti problema.}
        \item[Vzorčenje]{je proces izbire podmnožice agentov za kreiranje naslednje populacije.
            Največkrat izberemo agente glede na njihovo kvaliteto, zagotoviti pa moramo tudi zadostno raznolikost populacije,
            da ne obtičimo v lokalnih maksimumih. Poznamo več načinov vzorčenja, na primer~\cite{inteligentni_sistemi_2010}:
            \begin{itemize}
                \item proporcionalna izbira, kjer je verjetnost izbire agenta odvisna od njegove kakovosti glede na populacijo,
                \item rangovna izbira, kjer agente sortiramo po kvaliteti padajoče in jim priredimo rang glede na pozicijo, verjetnost izbire pa je odvisna od velikosti ranga,
                \item turnirska izbira, kjer izberemo naključno število agentov iz populacije, za križanje pa izberemo najkakovostnejšega
                z verjetnostjo $p$, drugega po vrsti z verjetnostjo $p*(1-p)$, tretjega z verjetnostjo $p*(1-p)^2$ itd.
                ($n$-tega izberemo z verjetnostjo $p*(1-p)^{n-1}$),
                \item stohastično univerzalno vzorčenje (SUS), ki je podrobneje opisano v razdelku~\ref{sec:vzorcenje}.
            \end{itemize}
            Agenta lahko izberemo večkrat.
            Taki agenti imajo po navadi visoko kakovost, kar pomeni večkratno udeležbo v križanju in s tem boljše širjenje kakovostnih genov na potomce.
            Prav tako ni nujno, da zamenjamo vse agente. V naslednjo populacijo lahko prenesemo del osebkov, pri
            čemer moramo paziti na raznolikost genetskega materiala. Ta koncept imenujemo elitizem~\cite{inteligentni_sistemi_2010}.
            \item}
        \item[Križanje]{je postopek izmenjave genov med agenti in je odvisen od njihove predstavitve in tega, kakšno informacijo posamezen gen predstavlja.
            Na primer, potomce agentov, ki so predstavljeni v vektorskem načinu, lahko ustvarimo tako, da vzamemo prvo polovico genov prvega in drugo polovico genov
            drugega starša. Križanje agentov, ki so predstavljeni z drevesnimi strukturami ali grafi, je težje
            (naša implementacija je opisana v razdelku~\ref{sec:krizanje}).
            Rezultat križanja je lahko eden ali več agentov, nastopata pa lahko tudi več kot dva starša. }
        \item[Mutacija]{je postopek naključne spremembe enega ali več genov agenta. Omogoča nastanek genov, ki jih
            s postopkom križanja ne bi mogli ustvariti. Paziti moramo, da število mutiranih osebkov ni preveliko,
            da se izognemo naključnemu preiskovanju.}
    \end{description}

    Splošna psevdokoda genetskih algoritmov je naslednja~\cite{inteligentni_sistemi_2010}:

    \lstlistingslo{psevdokoda/ga.txt}


    \section{Nevroevolucija}\label{sec:nevroevolucija}
    Nevroevolucija je področje strojnega učenja, kjer agente (napovedne modele) ustvarimo z uporabo genetskih algoritmov.
    Agenti predstavljajo nek tip nevronskih mrež.
    Posamezen gen predstavlja vozlišče ali povezavo (direktno kodiranje), lahko pa
    predstavlja tudi načrt konstrukcije dela nevronske mreže (posredno kodiranje)~\cite{kassahun2007common}.

    Nevroevolucija je primerna na področju spodbujevanega učenja, kjer nas za izračun kvalitete zanima le uspešnost
    kreirane mreže.
    Na primer, rezultat neke igre lahko enostavno izmerimo (ali je agent zmagal, koliko točk je dobil, kako hiter je bil),
    vrednost pa uporabimo kot kakovost.
    Pri nadzorovanem učenju bi potrebovali podatkovno množico agentovih potez s pričakovanimi rezultati igre.
    V kolikor igra vsebuje elemente naključnosti, se izdelava take množice lahko izkaže kot težaven problem.

    Z razliko od konvencionalnih metod strojnega učenja z vzvratnim raz\-šir\-ja\-njem napake, ki uporabljajo nevronske mreže
    fiksne topologije, nevroevolucija optimizira topologijo, uteži povezav med vozlišči in druge parametre mrež.
    Za primer vzemimo aktivacijsko funkcijo ReLU~\cite{he2015delving}, ki je definirana z:
    \begin{equation}
        f(x)=
        \begin{cases}
            \text{x} & \quad\text{če je x}\ge0\\
            \text{ax} & \quad\text{sicer}\\
        \end{cases}
        \label{eq:parametric_relu}
    \end{equation}
    V postopku križanja in mutiranja mrež bi lahko optimizirali tudi parameter $a$, ki določa prepustnost negativnih aktivacijskih vrednosti.

    \textbf{TODO} podrobnejši opis nevroevolucije, obstoječi pristopi



    \chapter{Implementacija nevroevolucije}\label{ch:implementacija-nevroevolucije}
    To poglavje pokriva konkretno implementacijo konceptov nevroevolucije iz razdelka~\ref{sec:nevroevolucija}.

    Naš pristop izdela nevronsko mrežo za poljubno učno množico z zveznimi ali diskretnimi atributi, s ciljem je večrazredne klasifikacije.
    V tem poglavju je opisano:
    \begin{itemize}
        \item implementacija agentov (razdelek~\ref{sec:agenti}) v obliki samostojnih objektov,
        \item implementacija populacije (razdelek~\ref{sec:populacija}) in njeni parametri,
        \item postopek inicializacije populacije (razdelek~\ref{sec:inicializacija-populacije}),
        \item vzorčenje (razdelek~\ref{sec:vzorcenje}) z algoritmom stohastičnega univerzalnega vzor\-če\-nja,
        \item križanje (razdelek~\ref{sec:krizanje}) agentov z združevanjem dveh usmerjenih grafov,
        \item mutiranje (razdelek~\ref{sec:mutiranje}) potomcev in implementirane vrste mutacij,
        \item izračun kvalitete (\ref{sec:izracun-kakovosti}) agentov na podlagi točnosti in Matthewsovega korelacijskega koeficienta.
    \end{itemize}

    \section{Agenti}\label{sec:agenti}
    Agenti v našem pristopu so direktno zakodirane rekurenčne nevronske mreže v obliki usmerjenega grafa, kjer vsak gen
    predstavlja povezavo ali vozlišče.
    Vsak agent hrani informacijo o svoji kvaliteti, točnosti in MCC (razdelek~\ref{sec:izracun-kakovosti}), ki se ob inicializaciji populacije (razdelek~\ref{sec:inicializacija-populacije})
    in kreiranju novega agenta v koraku križanja (razdelek~\ref{sec:krizanje}) nastavijo na 0.
    V koraku izračuna kakovosti (razdelek~\ref{sec:izracun-kakovosti}) se v polja shrani izračunana vrednost.

    Polje \enquote{newAgent} hrani informacijo, ali je agent v trenutni iteraciji populacije nov oz.\ je bil vzorčen
    iz prejšnje iteracije.
    V kolikor je vrednost \textbf{false}, korak izračuna kakovosti take agente preskoči, saj bi ponoven izračun
    vrnil enako kvaliteto.

    Vozlišča in povezave usmerjenega grafa so v naši implementaciji samostojni objekti, ki hranijo medsebojne reference.
    Matrika sosednosti ni najbolj primerna, saj bi bila zaradi načina mutiranja (razdelek~\ref{sec:mutiranje})
    v veliki večini primerov redka\footnote{Redke oz. raztresene matrike so matrike, v katerih ima večina elementov vrednost 0.
    V primeru predstavitve nevronskih mrež s tako podatkovno strukturo vrednost posameznega elementa pomeni utež povezave
    med vozliščema $x_i$ in $y_j$.
    Če je vrednost 0, potem povezava med vozliščema ne obstaja.}.

    \subsection{Usmerjeni grafi}\label{subsec:usmerjeni-grafi}
    Objekti razreda \enquote{Graph} vsebujejo seznam referenc na vsa vhodna, izhodna in globoka vozlišča ter seznam referenc
    na vse povezave.
    Čeprav so te reference shranjene tudi v posameznih vozliščih in povezavah, nam redundantni seznami olajšajo
    implementacijo funkcije sprehoda skozi graf, ki je opisana v razdelku~\ref{sec:izracun-kakovosti}.

    Struktura grafa je pogojena z izbrano podatkovno množico.
    Število vhodnih vozlišč mora biti enako številu atributov podatkovne mno\-ži\-ce, šte\-vi\-lo izhodnih vozlišč pa enako številu razredov.
    Količina notranjih vozlišč se giblje od 0 do izbrane vrednosti parametra.
    Za množice razdelka~\ref{sec:izbrane-podatkovne-mnozice} vrednost $20$ predstavlja dovolj dobro razmerje med dovoljeno kompleksnostjo agentov in
    računsko zahtevnostjo.

    \subsection{Vozlišča}\label{subsec:vozlisca}
    Vozlišča v usmerjenih grafih izhajajo iz enostavnega razreda \enquote{Vertex}, ki vsebuje seznam referenc
    na svoje vhodne in izhodne povezave, indeks in vrednost.
    Razred implementira trivialno aktivacijsko funkcijo $f(x)=x$.

    Indeks je unikatna številka vozlišča, ki se nastavi ob kreiranju le-tega znotraj usmerjenega grafa.
    Začne se z 0, vsako novo vozlišče pa dobi indeks, ki je za 1 večje od prejšnjega največjega.
    Vhodna, globoka in izhodna vozlišča se indeksirajo medsebojno neodvisno.

    Vrednost se nastavi v koraku izračuna kakovosti (razdelek~\ref{sec:izracun-kakovosti}), vsebuje pa rezultat aktivacijske funkcije.

    Omenili smo, da obstajajo trije tipi vozlišč, ki so medsebojno logično in strukturno drugačni, izhajajo
    pa iz razreda \enquote{Vertex}.
    \begin{description}
        \item[Vhodna vozlišča (oznaka $i$)]{Vsebujejo dodatno besedilno labelo pripadajočega atributa podatkovne množice.
        Logike dodajanja \textbf{vhodnih} povezav ta vozlišča ne implementirajo.\ Njihova aktivacijska funkcija je nespremenjena, ker
        želimo skozi graf propagirati natanko takšne vrednosti, kot jih prejmemo iz podatkovne množice. }
        \item[Globoka vozlišča (oznaka $d$)]{Vsebujejo logiko dodajanja vhodnih in izhodnih povezav, hkrati pa prepišejo
        privzeto aktivacijsko funkcijo s puščajočo (leaky) ReLU\footnote{Puščajoča ReLU je variacija ReLU aktivacijske funkcije $f(x)=\max(0,x)$, ki dopušča propagiranje negativnih aktivacijskih
        vrednosti skozi nevronsko mrežo. Sorodna je parametričnem ReLU iz razdelka~\ref{sec:nevroevolucija}.}~\cite{maas2013rectifier}:
        \begin{equation}
            f(x)=
            \begin{cases}
                \text{x} & \quad\text{če je x}\ge0\\
                \text{0.01x} & \quad\text{sicer}\\
            \end{cases}
            \label{eq:leaky_relu}
        \end{equation}}
        \item[Izhodna vozlišča (oznaka $o$)]{Tako kot vhodna vozlišča, tudi izhodna vsebujejo dodatno besedilno labelo, ki predstavlja
        ustrezen razred podatkovne mno\-ži\-ce.\ Logike dodajanja \textbf{izhodnih} povezav ne implementirajo.
        Njihova aktivacijska funkcija je nespremenjena, ker je v koraku izračuna kakovosti pomembna samo največja
        vrednost vseh izhodnih vozlišč grafa. }
    \end{description}
    V grafih dopuščamo obstoj \enquote{mirujočih} globokih vozlišč, ki:
    \begin{itemize}
        \item niso dostopna preko nobenega vhodnega vozlišča,
        \item ne vplivajo na rezultat aktivacijskih funkcij drugih vozlišč,
        \item preko katerih ne moremo doseči izhodnih vozlišč.
    \end{itemize}
    Mirujoča vozlišča lahko postanejo aktivna, če je izbrana prava mutacija v koraku mutiranja agentov (razdelek~\ref{sec:mutiranje}).

    \subsection{Povezave}\label{subsec:povezave}
    Vsaka povezava razreda \enquote{Edge} vsebuje naslednje informacije:
    \begin{itemize}
        \item referenco na eno izvorno vozlišče,
        \item referenco na eno ponorno vozlišče,
        \item indeks, ki je unikaten glede na celoten graf (določi se na enak način kot za vozlišča v razdelku~\ref{subsec:vozlisca}),
        \item utež, ki se v koraku inicializacije populacije (razdelek~\ref{sec:inicializacija-populacije}) in mutiranja (razdelek~\ref{sec:mutiranje}) normalizira na vrednost med -1 in 1,
        \item največje število prečkanj.
    \end{itemize}
    Največje število prečkanj je lastnost, ki v klasičnih nevronskih mrežah ni potrebna, saj postopek sprehoda skozi graf
    vsako povezavo prečka največ ali natanko enkrat.
    Ker so naši agenti kodirani kot rekurenčne nevronske mreže, kjer so dovoljeni cikli (razdelek~\ref{subsec:rekurencne-nevronske-mreze}),
    nam to polje preprečuje neskončne sprehode skozi graf.
    Največja vrednost polja je ena od inicializacijskih parametrov.

    Tipa izvornega in ponornega vozlišča ene povezave se lahko pojavita samo v naslednjih kombinacijah:
    \begin{itemize}
        \item vhodni izvor, globok ponor,
        \item vhodni izvor, izhodni ponor,
        \item globok izvor in ponor,
        \item globok izvor, izhodni ponor.
    \end{itemize}
    Na ta način preprečimo pojav grafov, kjer:
    \begin{itemize}
        \item rezultat aktivacijskih funkcij vhodnih, globokih ali izhodnih vozlišč vpliva na
        rezultat aktivacijskih funkcij vhodnih vozlišč,
        \item rezultat aktivacijskih funkcij izhodnih vozlišč vpliva na rezultat aktivacijskih funkcij vhodnih,
        globokih ali izhodnih vozlišč.
    \end{itemize}


    \section{Populacija}\label{sec:populacija}
    Populacija je samostojen razred, ki vsebuje seznam referenc agentov, učno in testno množico ter logiko inicializacije populacije, vzorčenja,
    križanja in mutiranja.
    Hrani naslednje parametre, ki so potrebni v koraku inicializacije populacije:
    \begin{description}
        \item[Velikost populacije]{Pozitivno celo število, ki določa število agentov v populaciji po koraku inicializacije
            (razdelek~\ref{sec:inicializacija-populacije}) in križanja (razdelek~\ref{sec:krizanje}). Večje število pomeni večjo začetno raznolikost
        agentov in več prostora za agente z nišnimi geni. }
        \item[Število vhodnih vozlišč]{Pozitivno celo število, ki je enako šte\-vi\-lu atributov izbrane podatkovne množice.}
        \item[Število izhodnih vozlišč]{Pozitivna celoštevilska vrednost, ki je enaka šte\-vi\-lu razredov izbrane podatkovne množice.}
        \item[Največje število globokih vozlišč]{Pozitivno celo število, ki do\-lo\-ča, naj\-več koliko globokih vozlišč lahko vsebujejo
        agenti te populacije. Korak mutiranja (razdelek~\ref{sec:mutiranje}) lahko povzroči izgubo ali pridobitev novega globokega
        vozlišča, dokler je skupno število med 0 in vrednostjo tega parametra.}
        \item[Največje število povezav]{Pozitivna celoštevilska vrednosti, ki določi, naj\-več koliko povezav lahko obstaja
        znotraj posameznega agenta. Korak mutiranja (razdelek~\ref{sec:mutiranje}) lahko povzroči izgubo ali pridobitev nove povezave,
        dokler je skupno število med 0 in vrednostjo tega parametra. Skupno število vhodnih in izhodnih povezav posameznih vozlišč ni posebej omejeno. }
        \item[Delež mutiranih potomcev]{Delež potomcev, ustvarjenih v koraku kri\-žan\-ja (razdelek~\ref{sec:krizanje}), ki jih bomo
        mutirali.}
        \item[Največje število prečkanj]{Pozitivno celo število, ki določa naj\-več preč\-kanj povezav grafov
        celotne populacije. Uporabi se v koraku izračuna kakovosti agentov (razdelek~\ref{sec:izracun-kakovosti}).}
        \item[Seznam label atributov in razredov]{Labele se pripišejo vhodnim in izhodnim vozliščem. Uporabijo se pri izpisu
        agentov na konzolo in pri shranjevanju grafov v JSON datoteke. }
        \item[Metrika kvalitete]{Dve možni besedilni vrednosti, ki določata način izra\-ču\-na kakovosti v razdelku~\ref{sec:izracun-kakovosti};
        \enquote{ACC}, ki predstavlja točnost, in \enquote{MCC}, ki predstavlja Matthewsov korelacijski koeficient.}
        \item[Prispevek vozlišč]{Decimalna vrednost, ki je lahko negativna ali pozitivna.\ Vpliva na izračun kvalitete agenta v razdelku~\ref{sec:izracun-kakovosti}.
        Pozitivna vrednost povzroči, da v koraku vzorčenja~\ref{sec:vzorcenje} obdržimo agente z več vozlišči, negativna pa obratno.}
        \item[Prispevek povezav]{Decimalna vrednost, ki je lahko negativna ali pozitivna. Vpliv je podoben prispevku vozlišč.}
    \end{description}


    \section{Inicializacija populacije}\label{sec:inicializacija-populacije}
    Postopek inicializacije populacije ustvari $n$ naključnih agentov, kjer je $n$ parameter \enquote{Velikost populacije}.
    Proces je naslednji:
    \begin{enumerate}
        \item Ustvari se nova instanca razreda \enquote{Graph} s številom vhodnih in izhodnih vozlišč podanih
        preko parametrov.\ Število globokih vozlišč je naključno med 0 in vrednostjo parametra \enquote{največje število globokih vozlišč}.
        Ustvarjena vozlišča se označijo po pravilu, opisanem v razdelku~\ref{subsec:vozlisca}.\ Vsa vhodna in izhodna vozlišča
        dobijo besedilno labelo pripadajočega atributa oz.\ razreda.\ V primeru podatkovne množice Iris bodo vsi agenti
        vsebovali štiri vhodna vozlišča z labelami \enquote{sepal length in cm}, \enquote{sepal width in cm}, \enquote{petal length in cm} in
        \enquote{petal width in cm} ter tri izhodna vozlišča z labelami \enquote{Iris Setosa}, \enquote{Iris Versicolour} in
        \enquote{Iris Virginica}.
        \item Vozlišča grafa se povežejo z $m$ povezavami, kjer je $m$ naključno celo število med 0 in vrednostjo
        parametra \enquote{največje število povezav}.\ Vhodna in izhodna vozlišča povezav se izberejo naključno, kombinacije tipov pa
        morajo slediti pravilom razdelka~\ref{subsec:povezave}.
        V tem koraku vsaki povezavi določimo tudi naključno utež med -1 in 1 ter največje število prečkanj, ki je naključno število med 0 in parametrom
        \enquote{največje število prečkanj}.
        \item Normaliziramo uteži povezav grafa med -1 in 1.
        \item Ustvarimo novo instanco razreda \enquote{Agent}, kjer je edini argument instanca grafa.\ Polje \enquote{newAgent}
        je privzeto \textbf{true}, kar bo sprožilo izračun kvalitete (razdelek~\ref{sec:izracun-kakovosti}).
    \end{enumerate}
    Po inicializiranju začetne populacije sledi korak izračuna kakovosti.


    \section{Vzorčenje}\label{sec:vzorcenje}
    Vzorčenje je v programu implementirano s prilagojenim algoritmom stohastičnega univerzalnega vzorčenja~\cite{inteligentni_sistemi_2010},
    kjer vedno obdržimo najkvalitetnejšega agenta populacije.
    Metoda prejme dva argumenta, ki vplivata na izbiro:
    \begin{description}
        \item[Število agentov, ki jih želimo obdržati]{Vrednost mora biti večja od 0 in manjša od ali enaka velikosti populacije.
        Večja vrednost povzroči manj potomcev in manj mutacij.}
        \item[Metrika kvalitete]{Metrika, po kateri želimo izvajati vzorčenje. Lahko je točnost ali MCC (razdelek~\ref{sec:izracun-kakovosti}).}
    \end{description}
    Rezultat metode je podmnožica populacije, ki se v koraku križanja napolni do polne kapacitete (razdelek~\ref{sec:krizanje}).

    \subsection{Stohastično univerzalno vzorčenje (SUS)}\label{subsec:stohasticno-univerzalno-vzorcenje}
    Prednost algoritma SUS~\cite{inteligentni_sistemi_2010} je manjša varianca glede na funkcijo kvalitete od metod izbire v razdelku~\ref{sec:genetski-algoritmi}.
    Zagotavlja verjetnejšo izbiro kvalitetnih agentov, hkrati pa dopušča nekaj naključnosti.
    Zaradi teh lastnosti pomaga preprečiti prezgodnjo konvergenco agentov in ohranjati raznolikost.
    V primeru, da želimo obdržati samo polovico populacije, bo SUS večino agentov izbral izmed najboljših 50\%,
    nekaj pa izmed slabše polovice.
    Ne zagotavlja izbire npr.\ vseh najboljših 10\% agentov.
    Elitne agente lahko izbere večkrat, če je njihova kvaliteta dovolj velika glede na preostalo populacijo.

    SUS je v našem programu prilagojen tako, da vedno obdrži najboljšega agenta.
    Implementiran je na naslednji način:
    \begin{enumerate}
        \item Poišče agenta z največjo kvaliteto, izračunano v koraku izračuna kakovosti (razdelek~\ref{sec:izracun-kakovosti}), ki
        lahko upošteva tudi njegovo število globokih vozlišč in povezav s poljubno utežjo poleg izbrane metrike.
        V primeru, da imata dva agenta enako kvaliteto, izbere tistega, ki ima največjo kvaliteto brez velikostne kazni.
        Njegov indeks shrani v seznam izbranih.
        \item Izračuna vsoto kvalitete vseh agentov populacije.
        \item Izračuna dolžino intervala kot razmerje med vsoto kvalitete in številom agentov, ki jih hočemo obdržati.
        \item Izbere naključno vrednost med 0 in dolžino intervala, ki bo služila kot začetni odmik.
        \item Vstopi v zanko, ki izbira agente glede na njihovo širino na številskem traku (slika~\ref{fig:sus}).
        Zanka je predstavljena s spodnjo psevdokodo.
        \lstlistingslo{psevdokoda/stochastic.txt}
    \end{enumerate}

    \begin{figure}[H]
        \begin{center}
            \includesvg[width=12cm]{sus.svg}
        \end{center}
        \caption{Ilustracija SUS algoritma, kjer želimo obdržati 3 agente. Izbrani agenti bodo A, B in D. Če bi bil začetni odmik
        večji, bi bili izbrani agenti A, C in E.}
        \label{fig:sus}
    \end{figure}


    \section{Križanje}\label{sec:krizanje}
    Korak križanja agentov napolni podmnožico populacije iz koraka vzorčenja (razdelek~\ref{sec:vzorcenje}) s potomci.
    Operiramo samo nad globokimi vozlišči in povezavami.
    Vhodna in izhodna vozlišča morajo ustrezati podatkovni množici, zato so enaka vsem agentih populacije.

    Vsak potomec je izdelan v svoji procesorski niti, saj je proces neodvisen od ostalih potomcev, hkrati pa ne
    spreminja vzorčenih agentov.

    Algoritem križanja je naslednji:
    \begin{enumerate}
        \item Iz populacije izberemo dva različna naključna agenta oz.\ starša.
        \item Ustvarimo instanco potomca z vhodnimi in izhodnimi vozlišči, ki ustrezajo podatkovni množici.
        \item Najdemo unijo globokih vozlišč obeh staršev, nato pa ta vozlišča ustvarimo v potomcu.
        Dve vozlišči obravnavamo kot enaki, če imata enak indeks.
        \item Najdemo unijo povezav obeh staršev, nato pa te povezave ustvarimo v potomcu.
        Dve povezavi obravnavamo kot enaki, če v obeh starših povezujeta vozlišči enakega tipa in indeksa v enaki smeri.
        Če taki povezavi obstajata, potem izberemo utež in največje število prečkanj od naključnega starša.
    \end{enumerate}


    \section{Mutiranje}\label{sec:mutiranje}
    Po vsakem končanem postopku križanja na podlagi parametra \enquote{delež mutiranih potomcev} izračunamo delež potomcev,
    ki jim bomo mutirali.
    Izbira potomcev za mutacijo in tip mutacije sta naključna. 
    Vzorčenih agentov nikoli ne mutiramo.

    Implementirali smo sedem različnih tipov mutacij z enako možnostjo izbire:
    \begin{description}
        \item[Dodajanje globokega vozlišča]{Dodamo novo globoko vozlišče z na\-klju\-čno vhodno in izhodno povezavo, če
        potomec še nima maksimalnega dovoljenega števila vozlišč tega tipa.}
        \item[Odstranitev globokega vozlišča]{Odstranimo naključno globoko vozlišče z vsemi povezavami.}
        \item[Dodajanje povezave]{Dodamo novo povezavo z naključno utežjo in naključnim največjim
        številom prečkanj, če potomec še nima maksimalnega dovoljenega števila povezav. Izvorno in ponorno vozlišče je
        izbrano naključno po pravilih iz razdelka~\ref{subsec:povezave}. }
        \item[Odstranitev povezave]{Odstranimo naključno povezavo.}
        \item[Sprememba uteži]{Spremenimo utež naključne povezave.}
        \item[Sprememba števila dovoljenih prečkanj]{Spremenimo šte\-vi\-lo dovoljenih prečkanj naključne povezave.}
        \item[Minimizacija]{Agentu odstranimo vsa mirujoča globoka vozlišča in vse pripadajoče povezave. \enquote{Verig} globokih
        vozlišč ne združujemo zaradi nelinearnosti puščajoče ReLU aktivacijske funkcije.}
    \end{description}

    Mutiranje vsakega potomca in normaliziranje uteži po končanem postopku izvajamo v svoji procesorski niti.


    \section{Izračun kakovosti}\label{sec:izracun-kakovosti}
    Izračun kakovosti sledi korakoma inicializacije populacije in mutiranja potomcev.
    Proces propagira vse zapise učne množice skozi vse agente populacije, prebere napovedi,
    izpolni matriko zmot in izračuna točnost ali Matthewsov korelacijski koeficient (MCC).\ Postopek propagiranja vseh zapisov učne množice za posameznega agenta izvedemo v svoji
    procesorski niti, algoritem pa je naslednji:
    \lstlistingslo{psevdokoda/izracun.txt}

    Algoritem propagiranja vrednosti testne množice skozi graf se nahaja v metodi \enquote{traverse(di)}:
    \begin{enumerate}
        \item Vhodnim vozliščem nastavimo vrednosti, ki so enake atributom zapisa učne množice ($i$-to vrednost nastavimo $i$-tem vhodnem vozlišču).
        \item Ustvarimo prazno unikatno vrsto vozlišč $pendingVertices$ in prazno množico rezervnih vozlišč $backupVertices$.
        \item \label{itm:traverse_input_enqueue} V $pendingVertices$ dodamo vsa vhodna vozlišča s izhodnimi povezavami.\ Ostala vhodna vozlišča
        ignoriramo, saj ne bodo vplivala na vrednosti izhodnih vozlišč.
        \item \label{itm:traverse_pending_loop} Ponavljamo, dokler vrsta $pendingVertices$ ni prazna:
        \begin{enumerate}
            \item Prvo vozlišče v vrsti $pendingVertices$ prestavimo v spremenljivko $vertex$.
            \item Ponavljamo za vsako izhodno povezavo $edge$ vozlišča $vertex$:
            \begin{itemize}
                \item V kolikor je število prečkanj $edge$ že enako največjemu dovoljenemu številu prečkanj (parameter v razdelku~\ref{sec:populacija}),
                to iteracijo zanke zaključimo in nadaljujemo z naslednjo izhodno povezavo.
                \item Vrednost $vertex$ pomnožimo z utežjo $edge$, zmnožek pa pri\-šte\-je\-mo njenemu ponornemu vozlišču.\ Število prečkanj $edge$ povečamo za 1.
                \item Ponorno vozlišče povezave $edge$ dodamo vrsto, če izpolnjuje naslednja pogoja:
                \begin{description}
                    \item[Je globoko vozliče.]{Vsa vhodna vozlišča že dodamo v vrsto v koraku \ref{itm:traverse_input_enqueue}. Izhodnih vozlišč v vrsto
                    ne dodajamo, ker po naši zasnovi agentov nimajo izhodnih povezav.}
                    \item [Ima vsaj eno primerno izhodno povezavo.]{Imeti mora\linebreak izhodno povezavo,
                    ki ima število prečkanj manjše od zgornje meje. Vozlišča, ki temu pogoju ne zadoščajo, svoje vrednosti
                    ne morejo propagirati do izhodnih vozlišč grafa, zato jih ne obravnavamo.}
                \end{description}
                \item Preverimo, če ima katerakoli vhodna povezava ponornega vozlišča $edge$ število prečkanj manjše od meje.
                Obstoj take povezave pomeni, da na vrednost tega vozlišča lahko vpliva še kako drugo predhodno vozlišče, ki ga
                še nismo obravnavali.
                Lahko pomeni tudi, da smo vsa predhodna vozlišča že obravnavali, povezava pa dovoli več sprehodov, kot je potrebno, ali pa so del cikla.
                Če pogoj ni izpolnjen, ponorno vozlišče dodamo v $pendingVertices$ in izbrišemo iz $backupVertices$.
                V nasprotnem primeru ga dodamo v $backupVertices$.
            \end{itemize}
            \item Vrnemo se na začetek zanke, če vrsta $pendingVertices$ vsebuje vsaj eno vozlišče.
            \item Zanko prekinemo, če je množica $backupVertices$ prazna.\ Propagiranje je zaključeno.
            \item Če noben od zgornjih dveh pogojev ni izpolnjen, imamo rezervna vozlišča,
            katerih vrednost nismo mogli propagirati zaradi vsaj enega izmed naslednjih dveh razlogov:
            \begin{itemize}
                \item njihova vhodna vozlišča vsebujejo več sprehodov, kot je potrebno,
                \item so del cikla.
            \end{itemize}
            Poiščemo vozlišče v $backupVertices$, ki ima najmanjši seštevek preostalih prečkanj vhodnih povezav, in ga prestavimo
            v $pending\-Vertices$.\ Če je takih vozlišč več, potem vzamemo tistega z najmanjšim indeksom.
        \end{enumerate}
    \end{enumerate}

    Z izpolnjeno matriko zmot program izračuna kvaliteto agenta s pomočjo točnosti ali MCC, odvisno od inicializacijskega parametra populacije \enquote{metrika kvalitete}.
    Točnost izračuna s pomočjo naslednje formule:
    \begin{equation}
        \text{ACC}=\frac{c}{s},
        \label{eq:tocnost}
    \end{equation}
    kjer je:
    \begin{itemize}
        \item $s$ število zapisov množice in
        \item $c$ število vseh pravilnih napovedi.
    \end{itemize}

    MCC~\cite{mcc_wiki} je mera asociativnosti dveh ali več spremenljivk.
    V kontekstu matrike zmot so spremenljivke oz.\ pravilni in napovedani razredi pozitivno asociativni, če se večina pravilnih napovedi nahaja na ali blizu diagonale.
    Splošna formula je naslednja:
    \begin{equation}
        \text{MCC}={\frac {cs-{\vec {t}}\cdot {\vec {p}}}{{\sqrt {s^{2}-{\vec {p}}\cdot {\vec {p}}}}{\sqrt {s^{2}-{\vec {t}}\cdot {\vec {t}}}}}}\:,
        \label{eq:mcc}
    \end{equation}
    kjer je:
    \begin{itemize}
        \item $c$ število vseh pravilnih napovedi,
        \item $s$ število zapisov množice,
        \item $\vec{t}$ število pojavitev vseh razredov in
        \item $\vec{p}$ število napovedi vseh razredov.
    \end{itemize}

    Kvaliteti nato prištejemo oz.\ odštejemo prispevek velikosti grafa na podlagi inicializacijskih parametrov \enquote{prispevek vozlišč}
    in \enquote{prispevek povezav} na naslednji način:
    \begin{equation}
        \text{Kvaliteta}=
        \begin{cases}
            \text{ACC}+(m \cdot c_v+n \cdot c_p), & \text{če je metrika ACC} \\
            \text{MCC}+(m \cdot c_v+n \cdot c_p), & \text{če je metrika MCC}
        \end{cases},
        \label{eq:prispevek_velikosti}
    \end{equation}
    kjer je:
    \begin{itemize}
        \item $m$ število vozlišč,
        \item $n$ število povezav,
        \item $c_v$ prispevek vozlišč in
        \item $c_p$ prispevek povezav.
    \end{itemize}
    Negativna prispevka povzročita, da bodo v koraku vzorčenja~\ref{sec:vzorcenje} bolj pogosto izbrani tisti agenti, ki imajo večjo točnost oz.
    MCC in so hkrati manj kompleksni.

    Za lažjo predstavo algoritma vzemimo prvi zapis izmišljene učne množice z atributi A, B in C ter dvema razredoma in ga propagirajmo skozi preprost acikličen graf.
    Vrednosti so zaokrožene na tri decimalna mesta.
    \begin{center}
        \begin{tabular}{||c c c c||}
            \hline
            A & B & C & Razred \\ [0.5ex]
            \hline
            5.7 & 2.8 & 4.2 & 1 \\
            \hline
            6.6 & 5.8 & 2.2 & 0 \\
            \hline
            3.6 & 5.3 & 3.5 & 0 \\
            \hline
            3.8 & 8 & 6.8 & 1 \\
            \hline
            3.5 & 7.4 & 9.8 & 0 \\
            \hline
        \end{tabular}
    \end{center}

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[node distance={25mm}, thin, main/.style = {draw, circle}]
            \node[main] (i0) {$i_0$};
            \node[main] (i1) [below of=i0] {$i_1$};
            \node[main] (i2) [below of=i1] {$i_2$};
            \node[main] (d0) [right of=i1] {$d_0$};
            \node[main] (d1) [right of=i2] {$d_1$};
            \node[main] (d2) [right of=d0] {$d_2$};
            \node[main] (d3) [right of=d1] {$d_3$};
            \node[main] (o0) [above right of=d2] {$o_0$};
            \node[main] (o1) [below right of=d2] {$o_1$};
            \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1} (o0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1} (d0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1} (d1);
            \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1} (d1);
            \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 2} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1} (d3);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1} (o0);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1} (o1);
        \end{tikzpicture}
        \caption{Primer preprostega acikličnega grafa agenta s tremi vhodnimi vozlišči $i$, štirimi globokimi vozlišči $d$ in
        dvema izhodnima vozliščema $o$. Prvo število na povezavah je utež, drugo pa največje število prečkanj.}
        \label{fig:preprost_aciklicen_graf}
    \end{figure}

    \begin{longtable}[l]{p{0.465\linewidth}p{0.465\linewidth}}
        \toprule
        \multicolumn{1}{c}{Korak} & \multicolumn{1}{c}{Ilustracija} \\
        \midrule
        \endhead
        %% prva vrstica
        Vhodnim vozliščem nastavimo vrednosti, ki so enake atributom zapisa učne množice.
        Shranimo jih v $pendingVertices$.
        \begin{flushleft}
            $pendingVertices: i_0, i_1, i_2$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.75mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[thicc] (i0) {$5.7$};
                \node[thicc] (i1) [below of=i0] {$2.8$};
                \node[thicc] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$d_0$};
                \node[main] (d1) [right of=i2] {$d_1$};
                \node[main] (d2) [right of=d0] {$d_2$};
                \node[main] (d3) [right of=d1] {$d_3$};
                \node[main] (o0) [above right of=d2] {$o_0$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 0/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 0/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 0/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 0/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 0/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 0/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 0/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% druga vrstica
        Iz $pendingVertices$ vzamemo $i_0$.\ Njegovo vrednost propagiramo do vozlišča $o_0$ tako,
        da $5.7$ pomnožimo z utežjo povezave $0.03$, zmnožek pa prištejemo trenutni vrednosti $o_0$.
        Število prečkanj povezave povečamo za $1$.
        Ker je $o_0$ izhodno vozlišče, ga ne dodamo v $pendingVertices$.
        \begin{flushleft}
            $pendingVertices: i_1, i_2$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$d_0$};
                \node[main] (d1) [right of=i2] {$d_1$};
                \node[main] (d2) [right of=d0] {$d_2$};
                \node[main] (d3) [right of=d1] {$d_3$};
                \node[thicc] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->, very thick] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 0/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 0/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 0/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 0/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 0/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 0/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% tretja vrstica
        Iz $pendingVertices$ vzamemo $i_1$.\ Njegovo vrednost propagiramo do vozlišč $d_0$ in $d_1$.
        Vozlišče $d_0$ dodamo v $pendingVertices$, $d_1$ pa v $backupVertices$, ker njegove povezave z $i_2$ še nismo obravnavali.
        \begin{flushleft}
            $pendingVertices: i_2, d_0$
            $backupVertices: d_1$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[thicc] (d0) [right of=i1] {$0.42$};
                \node[thicc] (d1) [right of=i2] {$0.588$};
                \node[main] (d2) [right of=d0] {$d_2$};
                \node[main] (d3) [right of=d1] {$d_3$};
                \node[main] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->, very thick] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->, very thick] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 0/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 0/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 0/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 0/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% četrta vrstica
        Iz $pendingVertices$ vzamemo $i_2$.\ Njegovo vrednost propagiramo do vozlišča $d_1$.
        Tokrat $d_1$ shranimo v $pendingVertices$, ker je število prečkanj vseh njegovih vhodnih povezav enako meji.
        Pobrišemo ga iz $backupVertices$.
        \begin{flushleft}
            $pendingVertices: d_0, d_1$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[thicc] (d1) [right of=i2] {$3.444$};
                \node[main] (d2) [right of=d0] {$d_2$};
                \node[main] (d3) [right of=d1] {$d_3$};
                \node[main] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->, very thick] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 0/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 0/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 0/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% peta vrstica
        Iz $pendingVertices$ vzamemo $d_0$.\ Njegovo vrednost propagiramo do vozlišča $d_2$.
        Vozlišče $d_2$ shranimo v $backupVertices$.
        \begin{flushleft}
            $pendingVertices: d_1$
            $backupVertices: d_2$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[main] (d1) [right of=i2] {$3.444$};
                \node[thicc] (d2) [right of=d0] {$0.197$};
                \node[main] (d3) [right of=d1] {$d_3$};
                \node[main] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->, very thick] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 0/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 0/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% šesta vrstica
        Iz $pendingVertices$ vzamemo $d_1$.\ Njegovo vrednost propagiramo do vozlišč $d_2$ in $d_3$.
        Vozlišča $d_3$ ne shranimo nikamor, ker nima izhodnih povezav, $d_2$ pa se že nahaja v $backupVertices$.
        \begin{flushleft}
            $pendingVertices: prazno$
            $backupVertices: d_2$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[main] (d1) [right of=i2] {$3.444$};
                \node[thicc] (d2) [right of=d0] {$3.434$};
                \node[thicc] (d3) [right of=d1] {$3.444$};
                \node[main] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->, very thick] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
                \draw[->, very thick] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% sedma vrstica
        Vrsta $pendingVertices$ je prazna, zato iz množice $backupVertices$ vzamemo vozlišče, ki ima najmanjši seštevek
        preostalih prečkanj vhodnih povezav.
        V tem primeru v $pendingVertices$ prestavimo $d_2$.
        \begin{flushleft}
            $pendingVertices: d_2$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[main] (d1) [right of=i2] {$3.444$};
                \node[main] (d2) [right of=d0] {$3.434$};
                \node[main] (d3) [right of=d1] {$3.444$};
                \node[main] (o0) [above right of=d2] {$0.171$};
                \node[main] (o1) [below right of=d2] {$o_1$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 0/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 0/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% osma vrstica
        Iz $pendingVertices$ vzamemo $d_2$.\ Njegovo vrednost propagiramo do vozlišč $o_0$ in $o_1$.
        $PendingVertices$ in $backupVertices$ sta prazni, zato zaključimo s postopkom.
        \begin{flushleft}
            $pendingVertices: prazno$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[main] (d1) [right of=i2] {$3.444$};
                \node[main] (d2) [right of=d0] {$3.434$};
                \node[main] (d3) [right of=d1] {$3.444$};
                \node[thicc] (o0) [above right of=d2] {$0.343$};
                \node[thicc] (o1) [below right of=d2] {$2.06$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
                \draw[->, very thick] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
                \draw[->, very thick] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% deveta vrstica
        Indeks izhodnega vozlišča z največjo vrednostjo primerjamo z razredom vrstice testne množice.
        Največja vrednost se nahaja v $o_1$, kar pomeni, da je napoved grafa pravilna.
        \begin{flushleft}
            $pendingVertices: prazno$
            $backupVertices: prazno$
        \end{flushleft}
        &
        \raisebox{-0.95\height}{
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$5.7$};
                \node[main] (i1) [below of=i0] {$2.8$};
                \node[main] (i2) [below of=i1] {$4.2$};
                \node[main] (d0) [right of=i1] {$0.42$};
                \node[main] (d1) [right of=i2] {$3.444$};
                \node[main] (d2) [right of=d0] {$3.434$};
                \node[main] (d3) [right of=d1] {$3.444$};
                \node[main] (o0) [above right of=d2] {$0.343$};
                \node[thicc] (o1) [below right of=d2] {$2.06$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
            \end{tikzpicture}
        } \\
        \midrule
        %% deseta vrstica
        Povečamo celico $1,1$ v matriki zmot za $1$.
        Če bi graf napovedal razred 0, bi povečali celico $1,0$.
        &
        \begin{center}
            \begin{tabular}{||c c c c||}
                \hline
                razred & 0 & 1 & vsota \\ [0.5ex]
                \hline
                0 & 0 & 0 & 0 \\
                \hline
                1 & 0 & \textbf{1} & 1 \\
                \hline
                vsota & 0 & 1 & 1 \\
                \hline
            \end{tabular}
        \end{center} \\
        \bottomrule
    \end{longtable}

    Skozi graf propagirajmo še preostale vrstice učne množice in izpolnimo matriko zmot.
    \begin{longtable}[l]{p{0.465\linewidth}p{0.465\linewidth}}
        \toprule
        \multicolumn{1}{c}{Graf} & \multicolumn{1}{c}{Matrika zmot} \\
        \midrule
        \endhead
        %% prva vrstica
        \raggedright{$A: 6.6, B:5.8, C: 2.2$\linebreak Pravilen razred: $0$}\linebreak\newline
            \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
                \node[main] (i0) {$6.6$};
                \node[main] (i1) [below of=i0] {$5.8$};
                \node[main] (i2) [below of=i1] {$2.2$};
                \node[main] (d0) [right of=i1] {$0.87$};
                \node[main] (d1) [right of=i2] {$2.714$};
                \node[main] (d2) [right of=d0] {$2.96$};
                \node[main] (d3) [right of=d1] {$2.714$};
                \node[main] (o0) [above right of=d2] {$0.346$};
                \node[thicc] (o1) [below right of=d2] {$1.776$};
                \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
                \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
                \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
                \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
                \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
                \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
            \end{tikzpicture}
        &
        \begin{center}
            \begin{tabular}{||c c c c||}
                \hline
                razred & 0 & 1 & vsota \\ [0.5ex]
                \hline
                0 & 0 & \textbf{1} & 1 \\
                \hline
                1 & 0 & 1 & 1 \\
                \hline
                vsota & 0 & 2 & 2 \\
                \hline
            \end{tabular}
        \end{center} \\
        \midrule
        %% druga vrstica
        \raggedright{$A: 3.6, B:5.3, C: 3.5$\linebreak Pravilen razred: $0$}\linebreak\newline
        \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
            \node[main] (i0) {$3.6$};
            \node[main] (i1) [below of=i0] {$5.3$};
            \node[main] (i2) [below of=i1] {$3.5$};
            \node[main] (d0) [right of=i1] {$0.795$};
            \node[main] (d1) [right of=i2] {$3.493$};
            \node[main] (d2) [right of=d0] {$3.657$};
            \node[main] (d3) [right of=d1] {$3.493$};
            \node[main] (o0) [above right of=d2] {$0.291$};
            \node[thicc] (o1) [below right of=d2] {$2.194$};
            \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
            \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
            \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
        \end{tikzpicture}
        &
        \begin{center}
            \begin{tabular}{||c c c c||}
                \hline
                razred & 0 & 1 & vsota \\ [0.5ex]
                \hline
                0 & 0 & \textbf{2} & 2 \\
                \hline
                1 & 0 & 1 & 1 \\
                \hline
                vsota & 0 & 3 & 3 \\
                \hline
            \end{tabular}
        \end{center} \\
        \midrule
        %% tretja vrstica
        \raggedright{$A: 3.8, B:8, C: 6.8$\linebreak Pravilen razred: $1$}\linebreak\newline
        \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
            \node[main] (i0) {$3.8$};
            \node[main] (i1) [below of=i0] {$8$};
            \node[main] (i2) [below of=i1] {$6.8$};
            \node[main] (d0) [right of=i1] {$1.2$};
            \node[main] (d1) [right of=i2] {$6.304$};
            \node[main] (d2) [right of=d0] {$6.49$};
            \node[main] (d3) [right of=d1] {$6.304$};
            \node[main] (o0) [above right of=d2] {$0.439$};
            \node[thicc] (o1) [below right of=d2] {$3.894$};
            \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
            \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
            \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
        \end{tikzpicture}
        &
        \begin{center}
            \begin{tabular}{||c c c c||}
                \hline
                razred & 0 & 1 & vsota \\ [0.5ex]
                \hline
                0 & 0 & 2 & 2 \\
                \hline
                1 & 0 & \textbf{2} & 2 \\
                \hline
                vsota & 0 & 4 & 4 \\
                \hline
            \end{tabular}
        \end{center} \\
        \midrule
        %% četrta vrstica
        \raggedright{$A: 3.5, B:7.4, C: 9.8$\linebreak Pravilen razred: $0$}\linebreak\newline
        \begin{tikzpicture}[font=\tiny, node distance={19.35mm}, thin, main/.style = {draw, circle}, thicc/.style = {draw, circle, very thick}]
            \node[main] (i0) {$3.5$};
            \node[main] (i1) [below of=i0] {$7.4$};
            \node[main] (i2) [below of=i1] {$9.8$};
            \node[main] (d0) [right of=i1] {$1.11$};
            \node[main] (d1) [right of=i2] {$8.218$};
            \node[main] (d2) [right of=d0] {$8.247$};
            \node[main] (d3) [right of=d1] {$8.218$};
            \node[main] (o0) [above right of=d2] {$0.517$};
            \node[thicc] (o1) [below right of=d2] {$4.948$};
            \draw[->] (i0) -- node[midway, above, sloped, pos=0.5] {0.03, 1/1} (o0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.15, 1/1} (d0);
            \draw[->] (i1) -- node[midway, above, sloped, pos=0.5] {0.21, 1/1} (d1);
            \draw[->] (i2) -- node[midway, above, sloped, pos=0.5] {0.68, 1/1} (d1);
            \draw[->] (d0) -- node[midway, above, sloped, pos=0.5] {0.47, 1/2} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {0.94, 1/1} (d2);
            \draw[->] (d1) -- node[midway, above, sloped, pos=0.5] {1, 1/1} (d3);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.05, 1/1} (o0);
            \draw[->] (d2) -- node[midway, above, sloped, pos=0.5] {0.6, 1/1} (o1);
        \end{tikzpicture}
        &
        \begin{center}
            \begin{tabular}{||c c c c||}
                \hline
                razred & 0 & 1 & vsota \\ [0.5ex]
                \hline
                0 & 0 & \textbf{3} & 3 \\
                \hline
                1 & 0 & 2 & 2 \\
                \hline
                vsota & 0 & 5 & 5 \\
                \hline
            \end{tabular}
        \end{center} \\
        \bottomrule
    \end{longtable}

    Na podlagi matrike zmot lahko izračunamo točnost in MCC napovedi testne množice.
    \begin{equation}
        ACC=\frac{c}{s}=\frac{2}{5}=40\%\label{eq:tocnost_primer}
    \end{equation}
    \begin{equation}
        \begin{split}
            MCC={\frac {cs-{\vec {t}}\cdot {\vec {p}}}{{\sqrt {s^{2}-{\vec {p}}\cdot {\vec {p}}}}{\sqrt {s^{2}-{\vec {t}}\cdot {\vec {t}}}}}}= \\
            \frac{(0+2)\cdot 5 - 5\cdot 2 - 0 \cdot 3}{\sqrt{5^2-5^2-0^2}\sqrt{5^2-2^2-3^2}}=\frac{0}{0} = \infty
        \end{split}\label{eq:mcc_primer}
    \end{equation}
    Metrika MCC vrne vrednost $\infty$, če vedno napovemo isti razred.
    V programu take primere obravnavamo enako kot $0$.

    \chapter{Evalvacija}\label{ch:evalvacija}
    To poglavje pokriva poganjanje programa na podatkovnih množicah Iris, Wine, Car Evaluation in Statlog (Shuttle) in predstavitev rezultatov.
    Vse podatkovne množice, ki smo jih izbrali, vsebujejo učne primerov brez manjkajočih vrednosti, zvezne ali diskretne atribute in najmanj tri razrede.
    Na voljo so na UCI Machine Learning Repository~\cite{Dua:2019}.

    V tem poglavju je opisano:
    \begin{itemize}
        \item podatkovna množica Iris (razdelek~\ref{sec:iris}), na kateri je potekala večina razvoja programa,
        \item podatkovna množica Wine (razdelek~\ref{sec:wine}), kjer je cilj uvrstiti vina v tri kvalitetne razrede na podlagi trinajstih atributov,
        \item podatkovna množica Car Evaluation (razdelek~\ref{sec:car-evaluation}), kjer je cilj klasificirati avtomobile v štiri kvalitetne razrede,
        \item podatkovna množica Statlog (Shuttle) (razdelek~\ref{sec:statlog-shuttle}) s 58000 vrsticami, od katerih okoli 80\% pripada enemu razredu.
    \end{itemize}

    \section{Iris}\label{sec:iris}

    \begin{description}
        \item[Iris]{ Ta učna množica je najenostavnejša izmed izbranih. Vsebuje tri razrede po 50 učnih primerov s štirimi atributi,
            ki predstavljajo širino in dolžino cvetnih in čašnih listov cvetlic v rodu iris oz. perunik. Vsak razred predstavlja vrsto perunike.  }
        \item[Wine]{Je rezultat kemične analize italijanskih vin, pridobljenih iz treh različnih kultivarjev iz iste regije.
        Vsebuje tri kvalitetne razrede vin od 1 do 3 s skupaj 178 učnimi primeri s 13 atributi. }
        \item[Car Evaluation]
        \item[Statlog (Shuttle)]
    \end{description}

    \begin{center}
        \begin{tabular}{||c c c c||}
            \hline
            ime & št. učnih primerov & št. atributov & št. razredov \\ [0.5ex]
            \hline
            Iris & 150 & 4 & 3 \\
            \hline
            Wine & 178 & 13 & 3 \\
            \hline
            Car Evaluation & 545 & 18744 & 7560 \\
            \hline
            Statlog (Shuttle) & 88 & 788 & 6344 \\ [1ex]
            \hline
        \end{tabular}
    \end{center}

    \section{Wine}\label{sec:wine}

    \section{Car Evaluation}\label{sec:car-evaluation}

    \section{Statlog (Shuttle)}\label{sec:statlog-shuttle}

    \subsection{Načrt poskusov}\label{subsec:nacrt-poskusov}
    \textbf{TODO}
    \subsection{Rezultati}\label{subsec:rezultati}
    \textbf{TODO}
    \subsection{Primerjava z obstoječimi pristopi strojnega učenja}\label{subsec:primerjava-z-obstojecimi-pristopi-strojnega-ucenja}
    \textbf{TODO}


    \chapter{Zaključki, sklep}\label{ch:zakljucki-sklep}
    \textbf{TODO}


%\cleardoublepage
%\addcontentsline{toc}{chapter}{Literatura}

    %\printbibliography[heading=bibintoc,type=article,title={Članki v revijah}]

    %\printbibliography[heading=bibintoc,type=inproceedings,title={Članki v zbornikih}]

    %\printbibliography[heading=bibintoc,type=incollection,title={Poglavja v knjigah}]

    \printbibliography[heading=bibintoc,title={Celotna literatura}]


\end{document}

